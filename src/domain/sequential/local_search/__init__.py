from logging import debug, info
from random import choice
from typing import Any

from domain.models.solutions import Batch, Problem
from domain.sequential.local_search.operators import Move, Relocate
from domain.sequential.local_search.search import SimmulatedAnnealing, TabuSearch

LS_MAX_ITERATIONS = 10


class LocalSearch(Problem):
    """
    Local search interface to improve the initial solution.


    2. Neighborhood structure
        Moves...
            Swap: orders from different batches
            N-: orders from one batch to others

    TS
        To avoid cycling, solutions possessing some attributes of recently visited solution are forbidden, or tabu, for a number of iterations, unless they improve upon the best known solution possessing one of these attributes.

    SA
        The algorithm also embeds a mechanism allowing worse solutions...

    !! Multi-start


    MOVES
        In this study, we devise four operators to construct the neighbors of the current solution. The four operators address
        different aspects of the MVSPDP: The relocation operator and the inversion operator account for inter-route and intra-route
        variations, respectively. The selection operator processes the selection of pickup nodes in the MVSPDP. Furthermore, the
        addition/deletion operator adjusts the number of vehicles used.
        For generating the neighbors, the proposed TS randomly performs one of the four operators on the current solution and
        repeats this procedure until the predetermined neighborhood size is achieved. Two methods are proposed for determining
        the probability of an operator being selected: ﬁxed probability and adaptive probability control. More details on the four
        operators are presented below.
        Relocation. This operator produces an inter-route variation by moving a randomly chosen node to a previous or subsequent
        route. The destination is limited to keep the sequence of the polar angles of nodes as complete as possible. Fig. 3 illustrates
        an application of the relocation operator in which node v9 is randomly chosen and relocated to the subsequent route.
        Inversion. The inversion operator produces an intra-route variation that inverts a random partial route to alter the visiting
        order. An example of this operator is presented in Fig. 4. The chosen partial route v5 → v9 → v12 is inverted into v12 → v9 →
        v5

        TODO check projet GOPP

    !! How to recompute the new path?


    """

    current_solution: list[Batch]
    routing_method: Any
    operators: list[Move] = []
    strategies: dict[str, Any] = {}

    @property
    def tabu_search(self) -> TabuSearch:
        return self.strategies["tabu_search"]

    @property
    def simulated_annealing(self) -> SimmulatedAnnealing:
        return self.strategies["simulated_annealing"]

    def to_diversify(self, count: int) -> bool:
        """Diversify the search at the half of the iterations."""
        return count > LS_MAX_ITERATIONS // 2

    def initialize(self):
        operator_params = {
            "routing_method": self.routing_method,
        }
        self.operators = [Relocate(**operator_params)]
        self.strategies = {
            "simulated_annealing": SimmulatedAnnealing(),
            "tabu_search": TabuSearch(),
        }

    def should_continue(self, count: int) -> bool:
        return count < LS_MAX_ITERATIONS

    def compute_distance(self, solution: list[Batch]) -> float:
        return sum(batch.metrics.distance for batch in solution)

    def should_accept(self, new_solution: list[Batch], count: int) -> bool:
        """
        Integrate the tabu search memory and the simulated annealing criterion to accept or reject the new solution.
        The solution is accepted if it is not tabu and it is better than the current solution (based on the Metropolis criterion).
        """
        if self.tabu_search.is_tabu(new_solution):
            return False

        self.tabu_search.update_memory(
            new_solution, to_diversify=self.to_diversify(count)
        )

        improvement = self.compute_distance(
            self.current_solution
        ) - self.compute_distance(new_solution)
        is_better = self.simulated_annealing.metropolis_criterion(improvement)

        self.simulated_annealing.update_temperature()

        return is_better

    def select_operator(self) -> Move:
        return choice(self.operators)

    def solve(self) -> list[Batch]:
        """
        Local search algorithm to improve the initial solution.

        At each iteration, until the stopping criterion is met, a solution is generated by applying a randomly selected move operator to the current solution.
        If the new solution satisfies the acceptance criterion, based on Tabu Search and Simulated Annealing principles, it is accepted as the new current solution using a first improvement strategy.
        The search is diversified at the half of the iterations to escape from local minimums.
        Finally, the best solution found during the search is returned.

        A further improvement is to implement a best improvement strategy, exploiting the parallelism of the TSP problem.
        """
        return self.current_solution  # TODO implement local search
        count = 0
        self.initialize()
        info(f"Starting local search with {LS_MAX_ITERATIONS} iterations.")
        best_solution = self.current_solution

        while self.should_continue(count):
            count += 1
            operator = self.select_operator()
            new_solution = operator.apply(self.current_solution)

            if self.should_accept(new_solution, count):
                debug(
                    f"Local search | Iteration {count} | Accepted new solution with distance {self.compute_distance(new_solution)}."
                )
                self.current_solution = new_solution

        info(f"Local search finished after {count} iterations.")

        final_solution = (
            self.current_solution
            if self.compute_distance(self.current_solution)
            < self.compute_distance(best_solution)
            else best_solution
        )

        return final_solution
